isNumber = function (n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

JSONToArray = function(columns, objArray, selectedColumns, selectedColumnTypes) {
  var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray
  var str = ''
  
  var dataTable = []
  
  var row = []
  for (var i = 0; i < selectedColumns.length; i++) {
    row.push(selectedColumns[i])
  }
  
  dataTable.push(row)
  
  for (var i = 0; i < array.length; i++) {
    row = []
    for (var j = 0; j < selectedColumns.length; j++) {
      var column_type = selectedColumnTypes[j]
      if (typeof(column_type) === 'undefined' || column_type === "Auto") {
        if (isNumber(array[i][selectedColumns[j]])) {
          row.push(parseFloat(array[i][selectedColumns[j]]))
        } else {
          if (array[i][selectedColumns[j]].replace(' ','') === 'null') {
            row.push(null)
          } else {
            row.push(array[i][selectedColumns[j]])
          }          
        }
      } else if (column_type === "Number") {
        row.push(parseInt(array[i][selectedColumns[j]]))
      } else if (column_type === "Date") {
        row.push(new Date(array[i][selectedColumns[j]]))
      } else {
        row.push(array[i][selectedColumns[j]])
      }
    }
    dataTable.push(row)
  }
  
  return dataTable
}

JSONToCSV = function(columns, objArray) {
  var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray
  var str = ''
  
  for (var i = 0; i < columns.length; i++) {
    if (str != '') str += ','
    str += columns[i]
  }
  
  str += '\r\n'

  for (var i = 0; i < array.length; i++) {
      var line = '';
      for (var index in array[i]) {
          if (line != '') line += ','

          line += array[i][index]
      }

      str += line

      if (i < array.length - 1) {
        str +='\r\n'
      }
  }

  return str;
}

CSVToJSON = function(strData, strDelimiter) {  
  if (strData.indexOf(strDelimiter) === -1) return null
  var array = CSVToArray(strData, strDelimiter)
  var newArray = []
  for (var i = 0; i < array.length; i++) {
    if (array[i].length >= 1 && array[i][0] !== "") {
      newArray.push(array[i])
    }
  }
  var json = arrayToJSON(newArray)
  return json;
}

escapeMongoChars = function(str) {
  if (str.indexOf('.') !== -1) {
    str = str.replace(/\./g, 'U+FF04')
  }
  
  if (str.indexOf('$') !== -1) {
    str = str.replace(/\$/g, 'U+FF0E')
  }
  
  return str
}

unescapeMongoChars = function(str) {
  str = str.replace(/U\+FF04/g, '.')
  str = str.replace(/U\+FF0E/g, '$')
  return str
}

arrayToJSON = function(array) {
  var json = {};
  
  if (array.length > 0) {
    // first line is column names
    var cols = [];
    for (var i = 0; i < array[0].length; i++) {
      var col_str = array[0][i];
      cols.push(col_str);
    }
    json['columns'] = cols;
    var data = [];
    for (var i = 1; i < array.length; i++) {
      var row = {};
      for (var j = 0; j < cols.length; j++) {
        row[cols[j]] = array[i][j];
      }
      data.push(row);
    }
    json['data'] = data;
  }
  
  return json;
}


// code from: http://stackoverflow.com/questions/1293147/javascript-code-to-parse-csv-data

// This will parse a delimited string into an array of
// arrays. The default delimiter is the comma, but this
// can be overriden in the second argument.
CSVToArray = function(strData, strDelimiter){
  // Check to see if the delimiter is defined. If not,
  // then default to comma.
  strDelimiter = (strDelimiter || ",");

  // Create a regular expression to parse the CSV values.
  var objPattern = new RegExp(
    (
      // Delimiters.
      "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

      // Quoted fields.
      "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

      // Standard fields.
      "([^\"\\" + strDelimiter + "\\r\\n]*))"
    ),
    "gi"
    );


  // Create an array to hold our data. Give the array
  // a default empty first row.
  var arrData = [[]];

  // Create an array to hold our individual pattern
  // matching groups.
  var arrMatches = null;


  // Keep looping over the regular expression matches
  // until we can no longer find a match.
  while (arrMatches = objPattern.exec( strData )){

    // Get the delimiter that was found.
    var strMatchedDelimiter = arrMatches[ 1 ];

    // Check to see if the given delimiter has a length
    // (is not the start of string) and if it matches
    // field delimiter. If id does not, then we know
    // that this delimiter is a row delimiter.
    if (
      strMatchedDelimiter.length &&
      (strMatchedDelimiter != strDelimiter)
      ){

      // Since we have reached a new row of data,
      // add an empty row to our data array.
      arrData.push( [] );

    }


    // Now that we have our delimiter out of the way,
    // let's check to see which kind of value we
    // captured (quoted or unquoted).
    if (arrMatches[ 2 ]){

      // We found a quoted value. When we capture
      // this value, unescape any double quotes.
      var strMatchedValue = arrMatches[ 2 ].replace(
        new RegExp( "\"\"", "g" ),
        "\""
        );

    } else {

      // We found a non-quoted value.
      var strMatchedValue = arrMatches[ 3 ];

    }


    // Now that we have our value string, let's add
    // it to the data array.
    arrData[ arrData.length - 1 ].push( strMatchedValue );
  }

  // Return the parsed data.
  return( arrData );
}